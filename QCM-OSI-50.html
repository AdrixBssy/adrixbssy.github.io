<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QCM OSI & TCP/IP ‚Äî 50 al√©atoires</title>

  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b1020;color:#e8ecff}
    header{padding:18px 16px;background:#111a33;border-bottom:1px solid rgba(255,255,255,.08);position:sticky;top:0;z-index:10}
    header h1{margin:0 0 8px 0;font-size:18px}
    header .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .meta{display:flex;flex-wrap:wrap;gap:10px;align-items:center;color:#b9c2ff;font-size:14px}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08)}
    button{background:#2b5cff;color:#fff;border:0;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer}
    button.secondary{background:#26304f}
    button:disabled{opacity:.55;cursor:not-allowed}

    /* --- Panneau acronymes (fixe √† gauche) --- */
    #acronymBox{
      position:fixed;
      left:10px;
      top:170px;
      width:210px;
      max-height:72vh;
      overflow:auto;

      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;

      backdrop-filter: blur(6px);
    }
    #acronymBox h3{margin:0 0 10px 0;font-size:14px;color:#b9c2ff;display:flex;align-items:center;gap:8px}
    #acroSearch{
      width:100%;
      box-sizing:border-box;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.20);
      color:#e8ecff;
      outline:none;
      margin-bottom:10px;
      font-size:13px;
    }
    #acroSearch::placeholder{color:rgba(185,194,255,.65)}
    .acro-item{padding:8px 8px;border-radius:12px;border:1px solid rgba(255,255,255,.06);background:rgba(0,0,0,.10);margin-bottom:8px}
    .acro-key{font-weight:800;color:#9db4ff}
    .acro-value{color:#b9c2ff;font-size:12px;line-height:1.35;margin-top:3px}

    /* --- Contenu principal --- */
    .wrap{max-width:1000px;margin:0 auto;padding:16px;margin-left:240px}
    .card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:14px;margin:12px 0}
    .qtitle{margin:0 0 10px 0;font-size:15px;line-height:1.35}
    .choices{display:grid;gap:8px}
    label.choice{display:flex;gap:10px;align-items:flex-start;padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.12);cursor:pointer}
    label.choice:hover{border-color:rgba(43,92,255,.6)}
    input[type="radio"]{margin-top:2px}
    .footerbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin:14px 0}
    .nav{display:flex;gap:8px;flex-wrap:wrap}
    .result{padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18)}
    .ok{outline:2px solid rgba(0,255,150,.35)}
    .bad{outline:2px solid rgba(255,80,80,.40)}
    .explain{color:#cfd6ff;font-size:13px;margin-top:8px;opacity:.95}
    .small{font-size:13px;color:#b9c2ff}

    /* --- Apr√®s correction : rendre visible le choix de l'utilisateur --- */
    label.choice.selected {
      border-color: rgba(255,255,255,.35);
      outline: 2px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
    }
    label.choice.selected.correct {
      outline: 2px solid rgba(0,255,150,.35);
      border-color: rgba(0,255,150,.35);
    }
    label.choice.selected.wrong {
      outline: 2px solid rgba(255,80,80,.40);
      border-color: rgba(255,80,80,.40);
    }
    /* (Optionnel) Montrer aussi la bonne r√©ponse m√™me si non choisie */
    label.choice.correct-answer {
      border-color: rgba(0,255,150,.25);
      background: rgba(0,255,150,.06);
    }

    /* --- Mobile: panneau en haut (non fixe) --- */
    @media (max-width: 900px){
      #acronymBox{
        position:static;
        width:auto;
        max-height:none;
        margin:12px 16px 0 16px;
      }
      .wrap{margin-left:0}
    }
  </style>
</head>

<body>
<header>
  <div class="row">
    <h1>QCM OSI & TCP/IP ‚Äî 50 al√©atoires</h1>
  </div>
  <div class="row meta">
    <span class="pill" id="pillBank">Banque: ‚Ä¶</span>
    <span class="pill" id="pillCount">Questions: ‚Ä¶</span>
    <span class="pill" id="pillPage">Page: ‚Ä¶</span>
    <span class="pill" id="pillAnswered">R√©pondu: ‚Ä¶</span>
    <span class="pill" id="pillScore">Score: ‚Äî</span>
  </div>
  <div class="row" style="margin-top:10px">
    <button id="btnPrev" class="secondary">‚óÄ Page pr√©c√©dente</button>
    <button id="btnNext" class="secondary">Page suivante ‚ñ∂</button>
    <button id="btnFinish">Corriger</button>
    <button id="btnNew" class="secondary">Nouveau QCM (50)</button>
    <button id="btnReset" class="secondary">Effacer r√©ponses</button>
  </div>
</header>

<!-- Panneau Acronymes -->
<div id="acronymBox">
  <h3>üìò Acronymes</h3>
  <input id="acroSearch" type="text" placeholder="Rechercher (ex: DNS, VLAN‚Ä¶)" />
  <div id="acroList"></div>
</div>

<div class="wrap">
  <div class="result" id="resultBox" style="display:none"></div>
  <div id="questions"></div>

  <div class="footerbar">
    <div class="nav">
      <button id="btnPrev2" class="secondary">‚óÄ Page pr√©c√©dente</button>
      <button id="btnNext2" class="secondary">Page suivante ‚ñ∂</button>
    </div>
    <div class="small"> TSSR - 2026 </div>
  </div>
</div>

<script>
/* ===========================
   Acronymes (panneau √† gauche)
   (On NE les injecte PAS dans les questions)
=========================== */
const ACRONYMS = {
  "ACK": "Acknowledgment (accus√© de r√©ception TCP)",
  "ARP": "Address Resolution Protocol",
  "BGP": "Border Gateway Protocol",
  "CIDR": "Classless Inter-Domain Routing",
  "CNAME": "Canonical Name (alias DNS)",
  "DHCP": "Dynamic Host Configuration Protocol",
  "DNS": "Domain Name System",
  "DoH": "DNS over HTTPS",
  "DoT": "DNS over TLS",
  "DORA": "Discover / Offer / Request / ACK (s√©quence DHCP)",
  "Ethernet": "Technologie r√©seau filaire L2",
  "FIN": "Finish (fin de connexion TCP)",
  "FTP": "File Transfer Protocol",
  "FTPS": "FTP over TLS/SSL",
  "HTTP": "HyperText Transfer Protocol",
  "HTTPS": "HyperText Transfer Protocol Secure",
  "ICMP": "Internet Control Message Protocol",
  "IKE": "Internet Key Exchange",
  "IMAP": "Internet Message Access Protocol",
  "IP": "Internet Protocol",
  "IPsec": "Internet Protocol Security",
  "IPv4": "Internet Protocol version 4",
  "IPv6": "Internet Protocol version 6",
  "L2TP": "Layer 2 Tunneling Protocol",
  "LDAP": "Lightweight Directory Access Protocol",
  "MAC": "Media Access Control (adresse L2)",
  "MTU": "Maximum Transmission Unit",
  "MX": "Mail Exchanger (DNS)",
  "NAT": "Network Address Translation",
  "NS": "Name Server (DNS)",
  "NTP": "Network Time Protocol",
  "OSI": "Open Systems Interconnection (mod√®le √† 7 couches)",
  "OSPF": "Open Shortest Path First",
  "POP3": "Post Office Protocol v3",
  "PPTP": "Point-to-Point Tunneling Protocol",
  "PTR": "Pointer (DNS inverse)",
  "QoS": "Quality of Service",
  "RDP": "Remote Desktop Protocol",
  "RIP": "Routing Information Protocol",
  "RPC": "Remote Procedure Call",
  "RST": "Reset (r√©initialisation TCP)",
  "SFTP": "SSH File Transfer Protocol",
  "SIP": "Session Initiation Protocol",
  "SMB": "Server Message Block",
  "SMTP": "Simple Mail Transfer Protocol",
  "SMTPS": "SMTP over TLS/SSL",
  "SNMP": "Simple Network Management Protocol",
  "SRV": "Service record (DNS)",
  "SSH": "Secure Shell",
  "STP": "Spanning Tree Protocol",
  "SYN": "Synchronize (d√©but handshake TCP)",
  "Syslog": "System Logging (journalisation r√©seau)",
  "TCP": "Transmission Control Protocol",
  "TCP/IP": "Suite de protocoles Internet (TCP + IP)",
  "Telnet": "Acc√®s distant non chiffr√© (ancien)",
  "TFTP": "Trivial File Transfer Protocol",
  "TLS": "Transport Layer Security",
  "TTL": "Time To Live",
  "UDP": "User Datagram Protocol",
  "URG": "Urgent (flag TCP, rare)",
  "VLAN": "Virtual LAN"
};

function renderAcronyms(filterText="") {
  const container = document.getElementById("acroList");
  const q = filterText.trim().toLowerCase();

  const sorted = Object.entries(ACRONYMS)
    .sort((a,b)=>a[0].localeCompare(b[0], "fr"));

  const filtered = sorted.filter(([k,v]) => {
    if (!q) return true;
    return k.toLowerCase().includes(q) || v.toLowerCase().includes(q);
  });

  container.innerHTML = filtered.map(([key, value]) => `
    <div class="acro-item">
      <div class="acro-key">${key}</div>
      <div class="acro-value">${value}</div>
    </div>
  `).join("") || `<div class="acro-value">Aucun r√©sultat.</div>`;
}

/* ===========================
   Utilitaires
=========================== */
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function uniqPush(list, item) {
  if (!list.includes(item)) list.push(item);
}
function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
function normKey(s){
  return String(s).trim().toLowerCase().replace(/\s+/g, " ");
}

/* ===========================
   Banque de 200 questions
=========================== */
const OSI = [
  {layer: 7, name:"Application", pdu:"Donn√©es", examples:["HTTP","DNS","SMTP","FTP","SSH","DHCP"]},
  {layer: 6, name:"Pr√©sentation", pdu:"Donn√©es", examples:["Chiffrement","Compression","Encodage","TLS"]},
  {layer: 5, name:"Session", pdu:"Donn√©es", examples:["Gestion de session","Synchronisation","RPC"]},
  {layer: 4, name:"Transport", pdu:"Segment (TCP) / Datagramme (UDP)", examples:["TCP","UDP"]},
  {layer: 3, name:"R√©seau", pdu:"Paquet", examples:["IP","ICMP","Routage","NAT"]},
  {layer: 2, name:"Liaison de donn√©es", pdu:"Trame", examples:["Ethernet","Wi-Fi (802.11)","VLAN","STP","MAC","ARP"]},
  {layer: 1, name:"Physique", pdu:"Bits", examples:["C√¢ble","Fibre","Radio","Signal"]},
];

const TCPIP = [
  {layer: 4, name:"Application", mapsOSI:"5-6-7", examples:["HTTP","DNS","SMTP","FTP","SSH","DHCP","TLS"]},
  {layer: 3, name:"Transport", mapsOSI:"4", examples:["TCP","UDP"]},
  {layer: 2, name:"Internet", mapsOSI:"3", examples:["IP","ICMP","Routage","NAT"]},
  {layer: 1, name:"Acc√®s r√©seau", mapsOSI:"1-2", examples:["Ethernet","Wi-Fi (802.11)","ARP","MAC","VLAN"]},
];

const PORTS = [
  ["HTTP",80,"TCP"], ["HTTPS",443,"TCP"], ["DNS",53,"UDP/TCP"], ["DHCP (client)",68,"UDP"], ["DHCP (serveur)",67,"UDP"],
  ["FTP (contr√¥le)",21,"TCP"], ["FTP (donn√©es)",20,"TCP"], ["SSH",22,"TCP"], ["Telnet",23,"TCP"],
  ["SMTP",25,"TCP"], ["POP3",110,"TCP"], ["IMAP",143,"TCP"],
  ["NTP",123,"UDP"], ["SNMP",161,"UDP"], ["SNMP Trap",162,"UDP"],
  ["LDAP",389,"TCP/UDP"], ["LDAPS",636,"TCP"],
  ["RDP",3389,"TCP/UDP"], ["SIP",5060,"UDP/TCP"], ["SIPS",5061,"TCP"],
  ["TFTP",69,"UDP"], ["SMB",445,"TCP"], ["Kerberos",88,"TCP/UDP"],
  ["MySQL",3306,"TCP"], ["PostgreSQL",5432,"TCP"], ["MongoDB",27017,"TCP"],
  ["HTTP Alt",8080,"TCP"], ["HTTPS Alt",8443,"TCP"],
  ["Syslog",514,"UDP"], ["BGP",179,"TCP"], ["OSPF",89,"IP"], ["RIP",520,"UDP"],
  ["IKE",500,"UDP"], ["IPsec NAT-T",4500,"UDP"], ["L2TP",1701,"UDP"], ["PPTP",1723,"TCP"],
  ["SFTP",22,"TCP"], ["FTPS",990,"TCP"], ["SMTPS",465,"TCP"], ["Submission",587,"TCP"],
  ["DoT",853,"TCP"], ["DoH",443,"TCP"], ["WireGuard",51820,"UDP"]
];

const PROTO_LAYER = [
  ["IP","R√©seau (OSI 3) / Internet (TCP/IP)"],
  ["ICMP","R√©seau (OSI 3) / Internet (TCP/IP)"],
  ["ARP","Liaison de donn√©es (OSI 2) (souvent entre L2/L3)"],
  ["TCP","Transport (OSI 4) / Transport (TCP/IP)"],
  ["UDP","Transport (OSI 4) / Transport (TCP/IP)"],
  ["HTTP","Application (OSI 7) / Application (TCP/IP)"],
  ["DNS","Application (OSI 7) / Application (TCP/IP)"],
  ["DHCP","Application (OSI 7) / Application (TCP/IP)"],
  ["TLS","Pr√©sentation/Application (OSI 6/7) (selon repr√©sentation)"],
  ["Ethernet","Liaison/Physique (OSI 2/1) / Acc√®s r√©seau"],
  ["VLAN","Liaison de donn√©es (OSI 2)"],
  ["STP","Liaison de donn√©es (OSI 2)"],
  ["NAT","R√©seau (OSI 3) (fonction)"],
];

const DEVICES = [
  ["Hub","Physique (OSI 1)"],
  ["R√©p√©teur","Physique (OSI 1)"],
  ["Switch (commutateur)","Liaison de donn√©es (OSI 2)"],
  ["Bridge (pont)","Liaison de donn√©es (OSI 2)"],
  ["Routeur","R√©seau (OSI 3)"],
  ["Point d‚Äôacc√®s Wi-Fi","Liaison de donn√©es (OSI 2)"],
  ["Pare-feu (filtrage L3/L4)","R√©seau/Transport (OSI 3/4)"],
  ["Proxy applicatif","Application (OSI 7)"],
];

const FACTS_TF = [
  ["TCP est orient√© connexion", "Vrai", "TCP √©tablit une connexion logique avant l‚Äô√©change de donn√©es."],
  ["UDP est orient√© connexion", "Faux", "UDP est sans connexion (connectionless)."],
  ["Le handshake TCP standard est en 3 temps (SYN, SYN-ACK, ACK)", "Vrai", "Le 3-way handshake d√©marre la connexion : SYN ‚Üí SYN-ACK ‚Üí ACK."],
  ["IPv4 utilise des adresses sur 32 bits", "Vrai", "IPv4 = 32 bits, ce qui donne environ 4,29 milliards d‚Äôadresses th√©oriques."],
  ["IPv6 utilise des adresses sur 128 bits", "Vrai", "IPv6 = 128 bits, donc un espace d‚Äôadressage immense (bien plus grand qu‚ÄôIPv4)."],
  ["Le TTL limite la dur√©e de vie d‚Äôun paquet", "Vrai", "Le TTL diminue √† chaque routeur. √Ä 0, le paquet est d√©truit (√©vite les boucles)."],
  ["ICMP sert notamment aux messages d‚Äôerreur et au diagnostic (ping)", "Vrai", "ICMP sert √† transporter des messages de contr√¥le (ex: ping / erreur de routage)."],
  ["DNS sert √† r√©soudre des noms de domaine en adresses IP", "Vrai", "DNS fait le lien entre nom (ex: exemple.com) et IP."],
  ["DHCP attribue automatiquement une configuration IP", "Vrai", "DHCP peut fournir IP + masque + passerelle + DNS automatiquement."],
  ["NAT permet souvent de partager une adresse IPv4 publique", "Vrai", "NAT traduit des IP priv√©es en une IP publique (souvent dans une box/routeur)."],
  ["Une trame Ethernet contient des adresses MAC source et destination", "Vrai", "En Ethernet (L2), on utilise des adresses MAC pour livrer la trame sur le LAN."],
  ["Un routeur choisit le chemin √† la couche R√©seau", "Vrai", "Le routeur travaille en L3 (IP) et d√©cide vers quel r√©seau envoyer les paquets."],
  ["Un switch op√®re principalement √† la couche Transport", "Faux", "Un switch classique est surtout L2 : il commute gr√¢ce aux adresses MAC."],
  ["TLS chiffre les √©changes applicatifs", "Vrai", "TLS apporte chiffrement + int√©grit√© + parfois authentification (certificat)."],
  ["MTU signifie Maximum Transmission Unit", "Vrai", "MTU = taille maximale d‚Äôun paquet sur un lien (ex: 1500 en Ethernet)."],
  ["CIDR remplace les classes A/B/C par des pr√©fixes /n", "Vrai", "CIDR utilise /24, /16, etc. au lieu des anciennes classes fixes."],
];

const IPV4_PRIVATE = [
  ["10.0.0.0/8","Priv√©e"],
  ["172.16.0.0/12","Priv√©e"],
  ["192.168.0.0/16","Priv√©e"],
];

const DNS_RECORDS = [
  ["A","Adresse IPv4"],
  ["AAAA","Adresse IPv6"],
  ["CNAME","Alias"],
  ["MX","Serveur mail"],
  ["NS","Serveur DNS autoritaire"],
  ["TXT","Texte/validation (SPF, etc.)"],
  ["PTR","R√©solution inverse"],
  ["SRV","Service (port/poids/priorit√©)"]
];

const TCP_FLAGS = [
  ["SYN","D√©marrer une connexion"],
  ["ACK","Accus√© de r√©ception"],
  ["FIN","Fin de connexion (fermeture propre)"],
  ["RST","R√©initialiser la connexion"],
  ["PSH","Pousser les donn√©es vers l‚Äôapplication"],
  ["URG","Donn√©es urgentes (rare)"],
];

const DHCP_STEPS = [
  ["Discover","D√©couverte client ‚Üí serveurs"],
  ["Offer","Proposition de bail"],
  ["Request","Demande du bail choisi"],
  ["ACK","Confirmation du bail"],
];

const SUBNET_QUICK = [
  ["/24","255.255.255.0"],
  ["/16","255.255.0.0"],
  ["/8","255.0.0.0"],
  ["/30","255.255.255.252"],
  ["/26","255.255.255.192"],
  ["/27","255.255.255.224"],
  ["/28","255.255.255.240"],
];

const VLAN_FACTS = [
  ["Un VLAN segmente un r√©seau L2 en domaines de broadcast s√©par√©s", "Vrai"],
  ["Une liaison trunk transporte plusieurs VLANs", "Vrai"],
  ["STP √©vite les boucles L2 dans un r√©seau commut√©", "Vrai"],
];

const QMAP = new Map(); // key -> question

function addQ(text, correct, wrongs, explain) {
  const key = normKey(text);
  if (QMAP.has(key)) return;

  const choices = [];
  uniqPush(choices, correct);
  for (const w of wrongs) uniqPush(choices, w);

  const fillers = ["Aucune de ces r√©ponses", "Toutes ces r√©ponses", "Cela d√©pend du contexte", "Non applicable"];
  for (const f of fillers) if (choices.length < 4) uniqPush(choices, f);

  const finalChoices = shuffle(choices.slice(0,4));
  const answerIndex = finalChoices.indexOf(correct);

  QMAP.set(key, {
    id: QMAP.size + 1,
    text,
    choices: finalChoices,
    answerIndex,
    explain: explain || ""
  });
}

function buildBank() {
  addQ("Combien de couches comporte le mod√®le OSI ?", "7", ["4","5","8"],
       "Le mod√®le OSI est une r√©f√©rence en r√©seau : il contient 7 couches (de 1 Physique √† 7 Application).");

  addQ("Combien de couches comporte le mod√®le TCP/IP ?", "4", ["3","5","7"],
       "Dans beaucoup de cours, TCP/IP est pr√©sent√© en 4 couches : Acc√®s r√©seau, Internet, Transport, Application.");

  for (const l of OSI) {
    addQ(`Dans le mod√®le OSI, quelle est la couche ${l.layer} ?`, l.name,
      shuffle(OSI.filter(x=>x.layer!==l.layer).map(x=>x.name)).slice(0,3),
      `Le mod√®le OSI a 7 couches. La couche ${l.layer} s'appelle "${l.name}".`
    );
    addQ(`Quel est le PDU typique de la couche OSI ${l.layer} (${l.name}) ?`, l.pdu,
      shuffle(["Bits","Trame","Paquet","Segment (TCP) / Datagramme (UDP)"].filter(x=>x!==l.pdu)).slice(0,3),
      `Un PDU est le ‚Äúnom des donn√©es‚Äù √† une couche donn√©e. Pour "${l.name}", on parle surtout de : ${l.pdu}.`
    );
    for (const ex of l.examples.slice(0,2)) {
      addQ(`√Ä quelle couche OSI associe-t-on le plus souvent ${ex} ?`, l.name,
        shuffle(OSI.filter(x=>x.layer!==l.layer).map(x=>x.name)).slice(0,3),
        `${ex} est g√©n√©ralement associ√© √† la couche "${l.name}" dans les cours OSI (√ßa peut varier selon les sources).`
      );
    }
  }

  for (const l of TCPIP) {
    addQ(`Dans le mod√®le TCP/IP (4 couches), quelle est la couche ${l.layer} ?`, l.name,
      shuffle(TCPIP.filter(x=>x.layer!==l.layer).map(x=>x.name)).slice(0,3),
      `En TCP/IP (version 4 couches), la couche ${l.layer} s'appelle "${l.name}".`
    );
    addQ(`La couche TCP/IP ${l.name} correspond √† quelles couches OSI ?`, l.mapsOSI,
      shuffle(TCPIP.filter(x=>x.name!==l.name).map(x=>x.mapsOSI)).slice(0,3),
      `Correspondance classique : TCP/IP "${l.name}" ‚Üî OSI ${l.mapsOSI}.`
    );
    for (const ex of l.examples.slice(0,2)) {
      addQ(`Dans TCP/IP, ${ex} appartient le plus souvent √† quelle couche ?`, l.name,
        shuffle(TCPIP.filter(x=>x.name!==l.name).map(x=>x.name)).slice(0,3),
        `${ex} est g√©n√©ralement rattach√© √† la couche "${l.name}" en TCP/IP.`
      );
    }
  }

  for (const [svc, port, trans] of PORTS) {
    addQ(`Quel est le port le plus couramment associ√© √† ${svc} ?`, String(port),
      shuffle(PORTS.filter(x=>x[0]!==svc).slice(0,12).map(x=>String(x[1]))).slice(0,3),
      `Les ports servent √† identifier un service sur une machine. ${svc} est classiquement associ√© au port ${port}.`
    );
    addQ(`${svc} utilise le plus souvent quel type de transport ?`, trans,
      shuffle(["TCP","UDP","UDP/TCP","IP"].filter(x=>x!==trans)).slice(0,3),
      `${svc} utilise g√©n√©ralement ${trans}. (Certains services peuvent fonctionner dans plusieurs modes selon le contexte.)`
    );
  }

  for (const [proto, layerText] of PROTO_LAYER) {
    addQ(`√Ä quelle couche se rattache principalement ${proto} ?`, layerText,
      shuffle(PROTO_LAYER.filter(x=>x[0]!==proto).map(x=>x[1])).slice(0,3),
      `${proto} se situe principalement ici : ${layerText}.`
    );
  }

  for (const [dev, layer] of DEVICES) {
    addQ(`√Ä quelle couche OSI associe-t-on le plus souvent ${dev} ?`, layer,
      shuffle(DEVICES.filter(x=>x[0]!==dev).map(x=>x[1])).slice(0,3),
      `On associe souvent ${dev} √† : ${layer}.`
    );
  }

  for (const [stmt, truth, expl] of FACTS_TF) {
    addQ(`${stmt}.`, truth,
      truth==="Vrai" ? ["Faux","√áa d√©pend","Non applicable"] : ["Vrai","√áa d√©pend","Non applicable"],
      expl || `R√©ponse : ${truth}.`
    );
  }

  for (const [range, kind] of IPV4_PRIVATE) {
    addQ(`Le r√©seau ${range} est une plage d‚Äôadresses :`, kind, ["Publique","Multicast","Loopback"],
      `Les plages priv√©es IPv4 les plus connues sont : 10.0.0.0/8, 172.16.0.0/12 et 192.168.0.0/16.`
    );
  }

  for (const [pref, mask] of SUBNET_QUICK) {
    addQ(`Quel masque correspond au pr√©fixe IPv4 ${pref} ?`, mask,
      shuffle(SUBNET_QUICK.filter(x=>x[0]!==pref).map(x=>x[1])).slice(0,3),
      `Rappel : le pr√©fixe ${pref} indique combien de bits sont pour le r√©seau. Ici, il correspond √† ${mask}.`
    );
    addQ(`Quel pr√©fixe CIDR correspond au masque ${mask} ?`, pref,
      shuffle(SUBNET_QUICK.filter(x=>x[1]!==mask).map(x=>x[0])).slice(0,3),
      `Rappel : ${mask} correspond au pr√©fixe ${pref}.`
    );
  }

  for (const [type, meaning] of DNS_RECORDS) {
    addQ(`Dans DNS, un enregistrement de type ${type} correspond √† :`, meaning,
      shuffle(DNS_RECORDS.filter(x=>x[0]!==type).map(x=>x[1])).slice(0,3),
      `M√©mo : A=IPv4, AAAA=IPv6, CNAME=alias, MX=mail, NS=serveur DNS, PTR=inverse, SRV=service.`
    );
  }

  for (let i = 0; i < DHCP_STEPS.length; i++) {
    const [step, meaning] = DHCP_STEPS[i];
    addQ(`Dans DHCP, que signifie l‚Äô√©tape ${step} ?`, meaning,
      shuffle(DHCP_STEPS.filter(x=>x[1]!==meaning).map(x=>x[1])).slice(0,3),
      `DHCP suit souvent DORA : Discover ‚Üí Offer ‚Üí Request ‚Üí ACK. Ici, ${step} = ${meaning}.`
    );
    addQ(`Dans DHCP, quelle est l‚Äô√©tape num√©ro ${i+1} (ordre classique DORA) ?`, step,
      shuffle(DHCP_STEPS.filter(x=>x[0]!==step).map(x=>x[0])).slice(0,3),
      `Ordre classique : Discover ‚Üí Offer ‚Üí Request ‚Üí ACK.`
    );
  }

  for (const [flag, role] of TCP_FLAGS) {
    addQ(`√Ä quoi sert principalement le drapeau TCP ${flag} ?`, role,
      shuffle(TCP_FLAGS.filter(x=>x[0]!==flag).map(x=>x[1])).slice(0,3),
      `Les flags TCP pilotent la connexion (ex: SYN d√©marre, ACK confirme, FIN ferme). Ici, ${flag} = ${role}.`
    );
  }

  for (const [stmt, truth] of VLAN_FACTS) {
    addQ(`${stmt}.`, truth,
      truth==="Vrai" ? ["Faux","√áa d√©pend","Non applicable"] : ["Vrai","√áa d√©pend","Non applicable"],
      `Rappel VLAN/STP : un VLAN s√©pare les domaines de broadcast ; STP √©vite les boucles L2 ; un trunk transporte plusieurs VLANs.`
    );
  }

  const MIX = [
    ["Quelle couche OSI est responsable du routage ?", "R√©seau", ["Transport","Session","Liaison de donn√©es"], "Le routage (choisir le chemin) se fait en OSI couche 3 (IP)."],
    ["Quel protocole traduit g√©n√©ralement IP ‚Üí MAC sur un LAN ?", "ARP", ["DNS","ICMP","TCP"], "ARP sert √† retrouver l‚Äôadresse MAC correspondant √† une IP sur un r√©seau local."],
    ["Dans OSI, la couche Physique transporte surtout :", "Bits", ["Trames","Paquets","Segments"], "La couche 1 g√®re le signal et transporte des bits."],
    ["Dans OSI, la couche Liaison manipule surtout :", "Trames", ["Bits","Paquets","Segments"], "La couche 2 transporte des trames et utilise les adresses MAC."],
    ["Dans OSI, la couche R√©seau manipule surtout :", "Paquets", ["Bits","Trames","Segments"], "La couche 3 manipule des paquets IP et fait du routage."],
    ["Dans OSI, la couche Transport manipule surtout :", "Segments (TCP) / Datagrammes (UDP)", ["Bits","Trames","Paquets"], "La couche 4 g√®re le transport : TCP (segments) ou UDP (datagrammes)."],
    ["Quel est le r√¥le principal d‚Äôun switch classique ?", "Commuter des trames via les adresses MAC", ["Router des paquets IP","Chiffrer via TLS","Attribuer des IP via DHCP"], "Un switch L2 utilise surtout la table MAC pour envoyer les trames au bon port."],
    ["Quel est le r√¥le principal d‚Äôun routeur ?", "Acheminer des paquets entre r√©seaux IP", ["Commuter des trames Ethernet","Coder/compresser les donn√©es","Cr√©er des sessions applicatives"], "Un routeur travaille en L3 : il relie des r√©seaux IP diff√©rents."],
    ["Le port 443 est associ√© √† :", "HTTPS", ["HTTP","SSH","DNS"], "HTTPS = HTTP s√©curis√© (TLS) sur le port 443."],
    ["Le port 53 est associ√© √† :", "DNS", ["DHCP","HTTP","SMB"], "DNS utilise principalement le port 53 (UDP le plus souvent, TCP parfois)."],
    ["La r√©solution inverse DNS est g√©n√©ralement r√©alis√©e via :", "PTR", ["MX","CNAME","SRV"], "PTR sert √† faire IP ‚Üí nom (reverse DNS)."],
    ["Quel champ IP diminue √† chaque routeur (IPv4) ?", "TTL", ["MTU","MAC","VLAN"], "TTL diminue √† chaque saut et √©vite les boucles infinies."],
    ["Quelle technologie segmente L2 en plusieurs domaines de broadcast ?", "VLAN", ["NAT","ICMP","TLS"], "Un VLAN s√©pare le r√©seau en domaines de broadcast distincts."],
    ["Quel protocole √©vite les boucles L2 dans un r√©seau commut√© ?", "STP", ["DNS","DHCP","SIP"], "STP bloque certains liens pour √©viter les boucles en couche 2."],
    ["Quelle est la fonction typique de NAT ?", "Traduire des adresses IP", ["R√©soudre des noms","Transporter des trames","G√©rer les sessions"], "NAT traduit des adresses (souvent priv√©es ‚Üí publique)."],
    ["Quel protocole est typiquement utilis√© pour attribuer IP/masque/passerelle automatiquement ?", "DHCP", ["DNS","ICMP","ARP"], "DHCP fournit automatiquement une configuration r√©seau."],
    ["Quel protocole sert √† diagnostiquer (ping) ?", "ICMP", ["TCP","ARP","SMTP"], "Ping utilise ICMP Echo Request/Reply."],
    ["Le port 22 correspond √† :", "SSH", ["FTP","Telnet","SMTP"], "SSH = acc√®s distant s√©curis√© sur 22."],
  ];
  for (const [t,c,w,e] of MIX) addQ(t,c,w,e);

  const protoToLikelyOSI = {
    "HTTP":"Application","HTTPS":"Application","DNS":"Application","DHCP":"Application","SMTP":"Application","FTP":"Application","SSH":"Application",
    "TCP":"Transport","UDP":"Transport",
    "IP":"R√©seau","ICMP":"R√©seau","NAT":"R√©seau",
    "ARP":"Liaison de donn√©es","Ethernet":"Liaison de donn√©es","VLAN":"Liaison de donn√©es","STP":"Liaison de donn√©es",
    "TLS":"Pr√©sentation"
  };
  const allProtos = ["HTTP","HTTPS","DNS","DHCP","ICMP","ARP","TCP","UDP","SMTP","FTP","SSH","NTP","SNMP","LDAP","SMB","SIP","TLS","VLAN","STP","NAT"];

  for (const p of allProtos) {
    const layer = protoToLikelyOSI[p] || "Application";
    addQ(`Dans le mod√®le OSI, ${p} est g√©n√©ralement associ√© √† quelle couche ?`, layer,
      shuffle(OSI.filter(x=>x.name!==layer).map(x=>x.name)).slice(0,3),
      `Astuce : HTTP/DNS/DHCP/SMTP sont souvent ‚ÄúApplication‚Äù, TCP/UDP ‚ÄúTransport‚Äù, IP/ICMP ‚ÄúR√©seau‚Äù, Ethernet/VLAN/STP ‚ÄúLiaison‚Äù.`
    );
  }

  for (const l of OSI) {
    addQ(`Quelle couche OSI porte le nom ${l.name} ?`, `Couche ${l.layer}`,
      shuffle(OSI.filter(x=>x.layer!==l.layer).map(x=>`Couche ${x.layer}`)).slice(0,3),
      `Rappel : ${l.name} correspond √† la couche ${l.layer}.`
    );
  }
}

buildBank();

const questionBankAll = Array.from(QMAP.values());

// V√©rification unicit√© + minimum 200
(function verifyUniqueMin200() {
  const seen = new Set();
  for (const q of questionBankAll) {
    const k = normKey(q.text);
    if (seen.has(k)) {
      console.error("Doublon d√©tect√© :", q.text);
      throw new Error("Doublon d√©tect√© dans la banque (texte identique).");
    }
    seen.add(k);
  }
  if (questionBankAll.length < 200) {
    console.error("Banque trop petite :", questionBankAll.length);
    throw new Error("La banque n'a pas atteint 200 questions uniques.");
  }
})();

// Banque finale = 200 uniques
const BANK_SIZE = 200;
const bank200 = questionBankAll.slice(0, BANK_SIZE);

/* ===========================
   Quiz actif: 50 al√©atoires sans r√©p√©tition
=========================== */
let questions = [];
const QUIZ_SIZE = 50;

const pageSize = 10; // 50 questions => 5 pages
let page = 0;
let userAnswers = [];
let corrected = false;

const elQ = document.getElementById("questions");
const pillBank = document.getElementById("pillBank");
const pillCount = document.getElementById("pillCount");
const pillPage = document.getElementById("pillPage");
const pillAnswered = document.getElementById("pillAnswered");
const pillScore = document.getElementById("pillScore");
const resultBox = document.getElementById("resultBox");

const btnPrev = document.getElementById("btnPrev");
const btnNext = document.getElementById("btnNext");
const btnPrev2 = document.getElementById("btnPrev2");
const btnNext2 = document.getElementById("btnNext2");
const btnFinish = document.getElementById("btnFinish");
const btnNew = document.getElementById("btnNew");
const btnReset = document.getElementById("btnReset");

function answeredCount() {
  return userAnswers.filter(x => x !== null).length;
}

function makeNewQuiz() {
  questions = shuffle(bank200).slice(0, QUIZ_SIZE);
  userAnswers = new Array(questions.length).fill(null);
  corrected = false;
  page = 0;
  resultBox.style.display = "none";
  pillScore.textContent = "Score: ‚Äî";
  render();
  window.scrollTo({top:0, behavior:"smooth"});
}

function resetAnswersOnly() {
  userAnswers = new Array(questions.length).fill(null);
  corrected = false;
  resultBox.style.display = "none";
  pillScore.textContent = "Score: ‚Äî";
  render();
  window.scrollTo({top:0, behavior:"smooth"});
}

/* ===========================
   Explications "d√©butant"
=========================== */
function getBeginnerExplain(q) {
  const text = String(q.text || "").toLowerCase();
  const correct = q.choices[q.answerIndex];

  const base = String(q.explain || "").trim();
  if (base.length >= 90) return base;

  const mOsiLayer = String(q.text || "").match(/couche\s+(\d)/i);
  if (text.includes("mod√®le osi") && mOsiLayer) {
    const n = mOsiLayer[1];
    return `Rappel OSI (7 couches) :
1 Physique (bits) ‚Üí 2 Liaison (trames / MAC) ‚Üí 3 R√©seau (paquets IP / routage) ‚Üí 4 Transport (TCP/UDP) ‚Üí 5 Session ‚Üí 6 Pr√©sentation (format/chiffrement) ‚Üí 7 Application (HTTP/DNS‚Ä¶).
Ici on te demande la couche ${n} : la bonne r√©ponse est "${correct}".`;
  }

  if (text.includes("pdu") || text.includes("segment") || text.includes("datagramme") || text.includes("trame") || text.includes("paquet")) {
    return `Un PDU est le ‚Äúnom des donn√©es‚Äù selon la couche :
- L1 : bits
- L2 : trame (Ethernet, MAC)
- L3 : paquet (IP)
- L4 : segment (TCP) / datagramme (UDP)
Donc ici : "${correct}".`;
  }

  if (text.includes("mod√®le tcp/ip") && text.includes("combien") && text.includes("couches")) {
    return `Version tr√®s courante du mod√®le TCP/IP (4 couches) :
1 Acc√®s r√©seau (Ethernet/Wi-Fi, MAC, ARP)
2 Internet (IP, routage)
3 Transport (TCP/UDP)
4 Application (HTTP, DNS, SMTP, DHCP‚Ä¶)
Donc : "${correct}".`;
  }

  if (text.includes("port")) {
    return `Les ports identifient un service sur une machine.
Exemples √† conna√Ætre : HTTP=80, HTTPS=443, DNS=53, SSH=22, SMTP=25.
Ici, le bon port est "${correct}".`;
  }

  if (text.includes("dns") && (text.includes("enregistrement") || text.includes("type"))) {
    return `M√©mo DNS :
A=IPv4, AAAA=IPv6, CNAME=alias, MX=mail, NS=serveur DNS, PTR=inverse (IP‚Üínom), SRV=service.
Ici : "${correct}".`;
  }

  if (text.includes("dhcp") && (text.includes("dora") || text.includes("discover") || text.includes("offer") || text.includes("request") || text.includes("ack") || text.includes("√©tape"))) {
    return `DHCP donne une config IP automatiquement.
Ordre DORA : Discover ‚Üí Offer ‚Üí Request ‚Üí ACK.
Ici : "${correct}".`;
  }

  if (text.includes("drapeau tcp") || text.includes("flag tcp") || text.includes("syn") || text.includes("ack") || text.includes("fin") || text.includes("rst")) {
    return `Flags TCP (√† retenir) :
SYN d√©marre, ACK confirme, FIN ferme proprement, RST coupe brutalement.
Ici : "${correct}".`;
  }

  if (correct === "Vrai" || correct === "Faux") {
    return `Astuce Vrai/Faux : rep√®re le protocole (TCP/UDP/DNS/IP...) puis rappelle la r√®gle de base.
Bonne r√©ponse : "${correct}".`;
  }

  if (text.includes("√† quelle couche") || text.includes("associe-t-on") || text.includes("appartient")) {
    return `Astuce couches :
- L2 : MAC, Ethernet, VLAN, STP (ARP est souvent ‚Äúentre L2/L3‚Äù)
- L3 : IP, ICMP, routage, NAT
- L4 : TCP, UDP
- L7 : HTTP, DNS, DHCP, SMTP‚Ä¶
Donc ici : "${correct}".`;
  }

  return base || `Bonne r√©ponse : "${correct}". Revois la r√®gle li√©e au mot-cl√© de la question (protocole, couche, port‚Ä¶).`;
}

/* ===========================
   Render
   - Couleur OK/Bad apr√®s correction
   - Explication UNIQUEMENT si faux ou non r√©pondu
   - Met en √©vidence la ligne choisie
=========================== */
function render() {
  const totalPages = Math.ceil(questions.length / pageSize);

  pillBank.textContent = `Banque: ${bank200.length} uniques`;
  pillCount.textContent = `Questions: ${questions.length}`;
  pillPage.textContent = `Page: ${page + 1}/${totalPages}`;
  pillAnswered.textContent = `R√©pondu: ${answeredCount()}/${questions.length}`;

  btnPrev.disabled = page === 0;
  btnPrev2.disabled = page === 0;
  btnNext.disabled = page >= totalPages - 1;
  btnNext2.disabled = page >= totalPages - 1;

  elQ.innerHTML = "";
  const start = page * pageSize;
  const end = Math.min(start + pageSize, questions.length);

  for (let i = start; i < end; i++) {
    const q = questions[i];
    const card = document.createElement("div");
    card.className = "card";
    card.id = `q-${i}`;

    const h = document.createElement("h3");
    h.className = "qtitle";
    h.textContent = `${i+1}. ${q.text}`;
    card.appendChild(h);

    const choices = document.createElement("div");
    choices.className = "choices";

    q.choices.forEach((choiceText, idx) => {
      const lab = document.createElement("label");
      lab.className = "choice";

      const inp = document.createElement("input");
      inp.type = "radio";
      inp.name = `q${i}`;
      inp.value = idx;
      inp.checked = userAnswers[i] === idx;
      inp.disabled = corrected;

      inp.addEventListener("change", () => {
        userAnswers[i] = idx;
        pillAnswered.textContent = `R√©pondu: ${answeredCount()}/${questions.length}`;
      });

      const span = document.createElement("div");
      span.textContent = choiceText;

      lab.appendChild(inp);
      lab.appendChild(span);

      // ‚úÖ Apr√®s correction : rendre visibles "choisi" + "bonne r√©ponse"
      if (corrected) {
        const ua = userAnswers[i];
        const correctIdx = q.answerIndex;

        if (idx === correctIdx) lab.classList.add("correct-answer");

        if (ua === idx) {
          lab.classList.add("selected");
          if (ua === correctIdx) lab.classList.add("correct");
          else lab.classList.add("wrong");
        }
      }

      choices.appendChild(lab);
    });

    card.appendChild(choices);

    if (corrected) {
      const ua = userAnswers[i];
      const correctIdx = q.answerIndex;
      const isCorrect = (ua === correctIdx);

      if (isCorrect) {
        card.classList.add("ok");
      } else {
        card.classList.add("bad");

        const exp = document.createElement("div");
        exp.className = "explain";

        const uaTxt = (ua === null) ? "‚Äî (non r√©pondu)" : q.choices[ua];
        const msg = (ua === null)
          ? "‚ö†Ô∏è Tu n‚Äôas pas r√©pondu √† cette question."
          : "‚ùå Ta r√©ponse est incorrecte.";

        exp.innerHTML = `
          <div><b>Ta r√©ponse :</b> ${uaTxt}</div>
          <div><b>Bonne r√©ponse :</b> ${q.choices[correctIdx]}</div>
          <div>${msg}</div>
          <div style="margin-top:6px;">${getBeginnerExplain(q)}</div>
        `;
        card.appendChild(exp);
      }
    }

    elQ.appendChild(card);
  }
}

function goToFirstWrong() {
  for (let i = 0; i < questions.length; i++) {
    if (userAnswers[i] !== questions[i].answerIndex) {
      page = Math.floor(i / pageSize);
      render();
      const el = document.getElementById(`q-${i}`);
      if (el) el.scrollIntoView({behavior:"smooth", block:"start"});
      return;
    }
  }
}

function grade() {
  corrected = true;

  let correct = 0;
  let unanswered = 0;
  for (let i = 0; i < questions.length; i++) {
    if (userAnswers[i] === null) unanswered++;
    if (userAnswers[i] === questions[i].answerIndex) correct++;
  }
  const score = Math.round((correct / questions.length) * 1000) / 10;

  pillScore.textContent = `Score: ${correct}/${questions.length} (${score}%)`;

  resultBox.style.display = "block";
  resultBox.innerHTML = `
    <div style="font-size:16px; font-weight:800; margin-bottom:6px;">R√©sultat</div>
    <div>‚úÖ Bonnes r√©ponses : <b>${correct}</b></div>
    <div>‚ùå Erreurs : <b>${questions.length - correct - unanswered}</b></div>
    <div>‚ö†Ô∏è Non r√©pondu : <b>${unanswered}</b></div>
    <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
      <button class="secondary" id="btnFirstWrong">Aller √† la premi√®re erreur</button>
      <button class="secondary" id="btnTop">Revenir en haut</button>
    </div>
    <div class="small" style="margin-top:10px;">
      Les questions sont encadr√©es en <b>vert</b> si correct, en <b>rouge</b> si incorrect.
    </div>
  `;

  document.getElementById("btnFirstWrong").onclick = goToFirstWrong;
  document.getElementById("btnTop").onclick = () => window.scrollTo({top:0, behavior:"smooth"});

  render();
  window.scrollTo({top:0, behavior:"smooth"});
}

btnPrev.onclick = () => { page = clamp(page - 1, 0, 9999); render(); window.scrollTo({top:0, behavior:"smooth"}); };
btnNext.onclick = () => { page = clamp(page + 1, 0, 9999); render(); window.scrollTo({top:0, behavior:"smooth"}); };
btnPrev2.onclick = btnPrev.onclick;
btnNext2.onclick = btnNext.onclick;

btnFinish.onclick = grade;
btnNew.onclick = makeNewQuiz;
btnReset.onclick = resetAnswersOnly;

// init
makeNewQuiz();
renderAcronyms();
document.getElementById("acroSearch").addEventListener("input", (e)=>renderAcronyms(e.target.value));

console.log("Banque finale:", bank200.length, "questions uniques.");
</script>
</body>
</html>
